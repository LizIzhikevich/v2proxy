-------------------------------------------------------------------------------
PROGRAMMABLE POLICIES & SIGNALS
-------------------------------------------------------------------------------

# purpose: protect certain resources from being terminated by users
# other than owner (and orginization)
# also make sure that non-owners are not able to change labels to break
# this policy
define policy resource limitDestruction {

    if resource.owner != $user :

	if resource.label contains "my_life's_work": 

	    protect delete  && protect terminate 

	protect change_label 

}


#Is this a policy? its more like a signal...should probably differentiate?
# purpose: print out the commands needed to terminate all cloud resources of this
# particular app
# differentiates b/w user invoked and app invoked (potentially output of program)
# resources

define signal app cleanUp {

    for id in app.resourcelist:

	if resourceList[id].invoke_origin == app.owner: 
	    print "client invoked: "
	else:
	    print "app invoked: "

	print resource.terminate_command(id)
	

}

run {

    appliedPolicies = [ limitDestruction ] #add More
    appliedSignals = [ cleanUp ]

    ./proxy 

} &

-------------------------------------------------------------------------------
DEFINED OBBJECTS & FUNCTIONS
-------------------------------------------------------------------------------


protect( action ) {

    if this.action == action:
	return false
    else:
	return true 

}


define proxy {

    resource = extractFromHTTPMessage # e.g., ec2, s3, lambdba

    # save mapping from resource-id to resource object itself
    app.resourceList[ resource[id] ] = resource 

    action = extractFromHTTPMessage # e.g., invoke, terminate, delete

    # speculatively try out the action and see if proxy will approve it
    success = spec_apply( resource, action, app )

    if success:
	deliver 
    else:
	block

}


#not sure what to make this method a part of
spec_apply( resource, action, app ) {

    for policy in appliedPolicies:

	if policy.invoke( resource, action, app ) != pass:
	    return false
    
    return true	    

}

define app * { # for all apps 

    resourceList = map < id, resource >
    owner = $user


}


-------------------------------------------------------------------------------
RESOURCE ABSTRACTION
-------------------------------------------------------------------------------


resource {

    id
    terminate_command( this_id )
    invoke_origin : client[ original_dest_addr ] 
    owner = $user
    label : http_message[ label ]


    s3 {

	id : http_message[ Bucket ] + http_message[ Key ]
	terminate_command( this_id ) : "aws s3api delete-bucket --bucket " + id


    }

    ec2 {

	id : http_message[ instanceID ] 
	terminate_command( this_id ): "aws ec2 terminate-instances --instance-ids " + this_id

    }
    
    lambda {

	id : http_message[ requestID ]
	terminate_command( this_id ): "there is no command to terminate a lambda"


    }

}

-------------------------------------------------------------------------------
Side Notes
-------------------------------------------------------------------------------

+ to make sure user restrictions don't override org ones, first apply user ones and then have org ones overwrite any that user might have written (aka org restrictions applied last with sudo permissions )

